#+title: Structure and Interpretation of Computer Programs
* Building Abstractions with Procedures (29)
** The Elements of Programming (34)
**** Expressions (35)
**** Naming and the Environment (38)
**** Evaluating Combinations (40)
**** Compound Procedures (43)
**** The Substitution Model for Procedure Application (46)
**** Conditional Expressions and Predicates (50)
**** Example: Square Roots by Newton's Method (56)
**** Procedures as Black-Box Abstractions (61)
** Procedures and the Processes They Generate (68)
**** Linear Recursion and Iteration (69)
**** Tree Recursion (75)
**** Orders of Growth (82)
**** Exponentiation (85)
**** Greatest Common Divisors (90)
**** Example: Testing for Primality (93)
** Formulating Abstractions with Higher-Order Procedures (102)
**** Procedures as Arguments (104)
**** Constructing Procedures Using lambda (111)
**** Procedures as General Methods (117)
**** Procedures as Returned Values (125)
* Building Abstractions with Data (135)
** Introduction to Data Abstraction (140)
**** Example: Arithmetic Operations for Rational Numbers (141)
**** Abstraction Barriers (146)
**** What Is Meant by Data? (150)
**** Extended Exercise: Interval Arithmetic (154)
** Hierarchical Data and the Closure Property (160)
**** Representing Sequences (162)
**** Hierarchical Structures (174)
**** Sequences as Conventional Interfaces (182)
**** Example: A Picture Language (200)
** Symbolic Data (220)
**** Quotation (220)
**** Example: Symbolic Differentiation (225)
**** Example: Representing Sets (232)
**** Example: Huffman Encoding Trees (246)
** Multiple Representations for Abstract Data (257)
**** Representations for Complex Numbers (259)
**** Tagged data (265)
**** Data-Directed Programming and Additivity (270)
** Systems with Generic Operations (282)
**** Generic Arithmetic Operations (282)
**** Combining Data of Different Types (290)
**** Example: Symbolic Algebra (301)
* Modularity Objects, and State (322)
** Assignment and Local State (324)
**** Local State Variables (325)
**** The Benefits of Introducing Assignment (333)
**** The Costs of Introducing Assignment (339)
** The Environment Model of Evaluation (348)
**** The Rules for Evaluation (350)
**** Applying Simple Procedures (355)
**** Frames as the Repository of Local State (358)
**** Internal Definitions (365)
** Modeling with Mutable Data (369)
**** Mutable List Structure (370)
**** Representing Queues (381)
**** Representing Tables (388)
**** A Simulator for Digital Circuits (397)
**** Propagation of Constraints (414)
** Concurrency: Time Is of the Essence (429)
**** The Nature of Time in Concurrent Systems (431)
**** Mechanisms for Controlling Concurrency (438)
** Streams (456)
**** Streams Are Delayed Lists (458)
**** Infinite Streams (469)
**** Exploiting the Stream Paradigm (481)
**** Streams and Delayed Evaluation (498)
**** Modularity of Functional Programs and Modularity of Objects (506)
*************** Abstraction (515)
** The Metacircular Evaluator (520)
**** The Core of the Evaluator (522)
**** Representing Expressions (529)
**** Evaluator Data Structures (540)
**** Running the Evaluator as a Program (545)
**** Data as Programs (550)
**** Internal Definitions (554)
**** Separating Syntactic Analysis from Execution (562)
** Variations on a Scheme — Lazy Evaluation (569)
**** Normal Order and Applicative Order (570)
**** An Interpreter with Lazy Evaluation (572)
**** Streams as Lazy Lists (583)
** Variations on a Scheme — Nondeterministic Computing (587)
**** Amb and Search (589)
**** Examples of Nondeterministic Programs (595)
**** Implementing the amb Evaluator (606)
** Logic Programming (622)
**** Deductive Information Retrieval (627)
**** How the Query System Works (643)
**** Is Logic Programming Mathematical Logic? (655)
**** Implementing the Query System (663)
****** The Driver Loop and Instantiation (663)
****** The Evaluator (666)
****** Finding Assertions by Pattern Matching (670)
****** Rules and Unification (673)
****** Maintaining the Data Base (679)
****** Stream Operations (682)
****** Query Syntax Procedures (684)
****** Frames and Bindings (687)
* Computing with Register Machines (694)
** Designing Register Machines (696)
**** A Language for Describing Register Machines (700)
**** Abstraction in Machine Design (706)
**** Subroutines (709)
**** Using a Stack to Implement Recursion (714)
**** Instruction Summary (723)
** A Register-Machine Simulator (724)
**** The Machine Model (726)
**** The Assembler (732)
**** Generating Execution Procedures for Instructions (736)
**** Monitoring Machine Performance (746)
** Storage Allocation and Garbage Collection (751)
**** Memory as Vectors (752)
**** Maintaining the Illusion of Infinite Memory (759)
** The Explicit-Control Evaluator (769)
**** The Core of the Explicit-Control Evaluator (771)
**** Sequence Evaluation and Tail Recursion (779)
**** Conditionals, Assignments, and Definitions (784)
**** Running the Evaluator (787)
** Compilation (795)
**** Structure of the Compiler (800)
**** Compiling Expressions (807)
**** Compiling Combinations (816)
**** Combining Instruction Sequences (825)
**** An Example of Compiled Code (830)
**** Lexical Addressing (845)
**** Interfacing Compiled Code to the Evaluator (850)
